"""integrate payment and gateway_transaction models

Revision ID: 7820b5bbc25f
Revises: f038fad8e588
Create Date: 2025-06-21 02:49:51.256388

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '7820b5bbc25f'
down_revision = 'f038fad8e588'
branch_labels = None
depends_on = None

# Enum imports for PaymentMethod, PaymentStatus, GatewayTransactionStatus, GatewayType
# Assuming they are accessible. If they were in models.enums, that would be:
# from models.enums import PaymentMethod, PaymentStatus
# For now, direct string values will be used in sa.Enum if not directly importable in migration
# or rely on the fact that SQLAlchemy can handle string representations if the enums are Python-only.
# However, for migrations, it's safer if the DB schema itself uses native ENUM types or varchar.
# For this migration, we'll define the enums as SQLAlchemy Enums directly.

payment_method_enum = sa.Enum('CASH_TO_LANDLORD', 'BANK_DEPOSIT_LANDLORD', 'MPESA_TO_LANDLORD_MANUAL', 'OTHER_MANUAL', 'MPESA_ONLINE_STK', 'GATEWAY_CARD', 'GATEWAY_MOBILE_MONEY', 'GATEWAY_OTHER', name='paymentmethod')
payment_status_enum = sa.Enum('EXPECTED', 'PENDING_CONFIRMATION', 'COMPLETED', 'PARTIALLY_PAID', 'FAILED', 'OVERDUE', 'CANCELLED', 'PENDING_APPROVAL', 'REFUNDED', 'PARTIALLY_REFUNDED', 'IN_DISPUTE', name='paymentstatus')
gateway_transaction_status_enum = sa.Enum('PENDING', 'SUCCESSFUL', 'FAILED', 'CANCELLED', 'PROCESSING', 'REQUIRES_ACTION', 'UNKNOWN', name='gatewaytransactionstatus')
gateway_type_enum = sa.Enum('MPESA_STK_PUSH', 'PESAPAL', 'STRIPE', 'FLUTTERWAVE', 'PAYPAL', 'BANK_TRANSFER_MANUAL_VERIFICATION', 'OTHER', name='gatewaytype')


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###

    # Workaround for persistent "table already exists" errors in sandbox:
    # Attempt to clean up objects this migration creates, in case a previous run failed.
    # This makes the upgrade more idempotent from a state where these objects might exist.
    # Note: Order of dropping constraints and tables is important.

    # Try dropping FKs first (in batch mode for SQLite)
    # These are FKs that will be created later in this script.
    try:
        with op.batch_alter_table('financial_transactions', schema=None) as batch_op:
            batch_op.drop_constraint(op.f('fk_financial_transactions_related_payment_id_payments'), type_='foreignkey')
    except Exception:  # Broad exception as constraint might not exist
        pass
    try:
        with op.batch_alter_table('gateway_transactions', schema=None) as batch_op:
            batch_op.drop_constraint(op.f('fk_gateway_transactions_payment_id_payments'), type_='foreignkey')
    except Exception: # Broad exception as constraint or table might not exist
        pass

    # Try dropping tables (and their indexes)
    # The FK from payments to gateway_transactions is part of payments table definition,
    # so payments should be dropped first if gateway_transactions exists and payments references it.
    # However, if gateway_transactions has an FK to payments, gateway_transactions should be dropped first.
    # Given our creation strategy (GT -> P -> add FK GT_to_P), we drop in reverse: GT, then P.
    # Actually, P has FK to GT, so P must be dropped first, or its FK to GT.
    # Let's ensure payments' FK to gateway_transactions is dropped if payments table is dropped.
    # Simpler: just try to drop gateway_transactions, then payments. If FKs prevent, this will show.
    # The `payments` table has an FK to `gateway_transactions`.
    # The `gateway_transactions` table has an FK to `payments`. This is the circular part.
    # The FK `fk_payments_gateway_transaction_id_gateway_transactions` is on `payments`.
    # The FK `fk_gateway_transactions_payment_id_payments` is on `gateway_transactions`.

    # To break the cycle for dropping:
    # 1. Drop FK on gateway_transactions pointing to payments (already done above)
    # 2. Drop payments table (this also drops its FK to gateway_transactions)
    # 3. Drop gateway_transactions table
    try:
        op.drop_table('payments') # This will also drop its indexes and FKs
    except Exception:
        pass
    try:
        op.drop_table('gateway_transactions') # This will also drop its indexes
    except Exception:
        pass

    # Original upgrade logic starts here
    # Create gateway_transactions table first as payments might reference it (though FK is on payments to gateway_transactions)
    # Actually, payments table first, then gateway_transactions, then add FK from payments to gateway_transactions if it's nullable
    # Or, create gateway_transactions, then payments, then financial_transactions.
    # The order below should work if FKs are added at the end or are nullable initially.

    # 1. Create gateway_transactions table (initially without FK to payments)
    op.create_table('gateway_transactions',
        sa.Column('transaction_id', sa.Integer(), nullable=False),
        sa.Column('payment_id', sa.Integer(), nullable=False), # FK will be added later
        sa.Column('gateway_type', gateway_type_enum, nullable=False),
        sa.Column('gateway_specific_transaction_id', sa.String(length=255), nullable=True),
        sa.Column('internal_merchant_ref', sa.String(length=255), nullable=True),
        sa.Column('status', gateway_transaction_status_enum, nullable=False),
        sa.Column('amount', sa.Numeric(precision=12, scale=2), nullable=False),
        sa.Column('currency', sa.String(length=10), nullable=False),
        sa.Column('payment_method_detail', sa.String(length=100), nullable=True),
        sa.Column('raw_request_payload', sa.JSON(), nullable=True),
        sa.Column('raw_response_payload', sa.JSON(), nullable=True),
        sa.Column('callback_payload', sa.JSON(), nullable=True),
        sa.Column('error_code', sa.String(length=100), nullable=True),
        sa.Column('error_message', sa.Text(), nullable=True),
        sa.Column('notes', sa.Text(), nullable=True),
        sa.Column('initiated_at', sa.DateTime(), nullable=False),
        sa.Column('last_updated_at', sa.DateTime(), nullable=False),
        sa.PrimaryKeyConstraint('transaction_id', name=op.f('pk_gateway_transactions'))
    )
    op.create_index(op.f('ix_gateway_transactions_gateway_specific_transaction_id'), 'gateway_transactions', ['gateway_specific_transaction_id'], unique=False)
    op.create_index(op.f('ix_gateway_transactions_internal_merchant_ref'), 'gateway_transactions', ['internal_merchant_ref'], unique=False)
    op.create_index(op.f('ix_gateway_transactions_payment_id'), 'gateway_transactions', ['payment_id'], unique=False) # Index on payment_id
    op.create_index(op.f('ix_gateway_transactions_status'), 'gateway_transactions', ['status'], unique=False)

    # 2. Create payments table (with its FK to gateway_transactions)
    op.create_table('payments',
        sa.Column('payment_id', sa.Integer(), nullable=False),
        sa.Column('lease_id', sa.Integer(), nullable=False),
        sa.Column('expected_amount', sa.Numeric(precision=12, scale=2), nullable=False),
        sa.Column('due_date', sa.Date(), nullable=True),
        sa.Column('payment_method', payment_method_enum, nullable=True),
        sa.Column('amount_paid', sa.Numeric(precision=12, scale=2), nullable=True),
        sa.Column('payment_date', sa.Date(), nullable=True),
        sa.Column('status', payment_status_enum, nullable=False),
        sa.Column('recorded_by_landlord_id', sa.Integer(), nullable=True),
        sa.Column('initiated_by_user_id', sa.Integer(), nullable=True),
        sa.Column('gateway_transaction_id', sa.Integer(), nullable=True),
        sa.Column('landlord_bank_account_id', sa.Integer(), nullable=True),
        sa.Column('bank_transaction_id', sa.String(length=255), nullable=True),
        sa.Column('reference_number', sa.String(length=255), nullable=True),
        sa.Column('payer_narration', sa.Text(), nullable=True),
        sa.Column('notes', sa.Text(), nullable=True),
        sa.Column('payment_reference_code', sa.String(length=50), nullable=True),
        sa.Column('created_at', sa.DateTime(), nullable=False),
        sa.Column('updated_at', sa.DateTime(), nullable=False),
        sa.ForeignKeyConstraint(['gateway_transaction_id'], ['gateway_transactions.transaction_id'], name=op.f('fk_payments_gateway_transaction_id_gateway_transactions')),
        sa.ForeignKeyConstraint(['initiated_by_user_id'], ['users.user_id'], name=op.f('fk_payments_initiated_by_user_id_users')),
        sa.ForeignKeyConstraint(['landlord_bank_account_id'], ['landlord_bank_accounts.account_id'], name=op.f('fk_payments_landlord_bank_account_id_landlord_bank_accounts')),
        sa.ForeignKeyConstraint(['lease_id'], ['leases.lease_id'], name=op.f('fk_payments_lease_id_leases')),
        sa.ForeignKeyConstraint(['recorded_by_landlord_id'], ['users.user_id'], name=op.f('fk_payments_recorded_by_landlord_id_users')),
        sa.PrimaryKeyConstraint('payment_id', name=op.f('pk_payments'))
    )
    op.create_index(op.f('ix_payments_due_date'), 'payments', ['due_date'], unique=False)
    op.create_index(op.f('ix_payments_gateway_transaction_id'), 'payments', ['gateway_transaction_id'], unique=False)
    op.create_index(op.f('ix_payments_initiated_by_user_id'), 'payments', ['initiated_by_user_id'], unique=False)
    op.create_index(op.f('ix_payments_landlord_bank_account_id'), 'payments', ['landlord_bank_account_id'], unique=False)
    op.create_index(op.f('ix_payments_lease_id'), 'payments', ['lease_id'], unique=False)
    op.create_index(op.f('ix_payments_payment_date'), 'payments', ['payment_date'], unique=False)
    op.create_index(op.f('ix_payments_payment_reference_code'), 'payments', ['payment_reference_code'], unique=True)
    op.create_index(op.f('ix_payments_recorded_by_landlord_id'), 'payments', ['recorded_by_landlord_id'], unique=False)
    op.create_index(op.f('ix_payments_status'), 'payments', ['status'], unique=False)

    # 3. Add FK from gateway_transactions to payments (using batch mode for SQLite)
    with op.batch_alter_table('gateway_transactions', schema=None) as batch_op:
        batch_op.create_foreign_key(
            op.f('fk_gateway_transactions_payment_id_payments'), # Name generated by op.f()
            'payments', # Target table
            ['payment_id'], ['payment_id'] # Local columns, Remote columns
        )

    # 4. Add foreign key constraint to financial_transactions table (using batch mode for SQLite)
    with op.batch_alter_table('financial_transactions', schema=None) as batch_op:
        batch_op.create_foreign_key(
            op.f('fk_financial_transactions_related_payment_id_payments'), # Name
            'payments', # Target table
            ['related_payment_id'], ['payment_id'] # Local columns, Remote columns
        )
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('financial_transactions', schema=None) as batch_op:
        batch_op.drop_constraint(op.f('fk_financial_transactions_related_payment_id_payments'), type_='foreignkey')

    with op.batch_alter_table('gateway_transactions', schema=None) as batch_op:
        batch_op.drop_constraint(op.f('fk_gateway_transactions_payment_id_payments'), type_='foreignkey')

    op.drop_index(op.f('ix_gateway_transactions_status'), table_name='gateway_transactions')
    op.drop_index(op.f('ix_gateway_transactions_payment_id'), table_name='gateway_transactions')
    op.drop_index(op.f('ix_gateway_transactions_internal_merchant_ref'), table_name='gateway_transactions')
    op.drop_index(op.f('ix_gateway_transactions_gateway_specific_transaction_id'), table_name='gateway_transactions')
    op.drop_table('gateway_transactions')

    op.drop_index(op.f('ix_payments_status'), table_name='payments')
    op.drop_index(op.f('ix_payments_recorded_by_landlord_id'), table_name='payments')
    op.drop_index(op.f('ix_payments_payment_reference_code'), table_name='payments')
    op.drop_index(op.f('ix_payments_payment_date'), table_name='payments')
    op.drop_index(op.f('ix_payments_lease_id'), table_name='payments')
    op.drop_index(op.f('ix_payments_landlord_bank_account_id'), table_name='payments')
    op.drop_index(op.f('ix_payments_initiated_by_user_id'), table_name='payments')
    op.drop_index(op.f('ix_payments_gateway_transaction_id'), table_name='payments')
    op.drop_index(op.f('ix_payments_due_date'), table_name='payments')
    op.drop_table('payments')

    # Drop Enums (PostgreSQL specific, might need adjustment for other DBs)
    # For SQLite, enums are typically handled as VARCHARs and don't need explicit dropping.
    # If using PostgreSQL native enums, they would be dropped here.
    # For this generic migration, we assume they are handled by SQLAlchemy's type system
    # or are implicitly dropped if not used.
    # Commenting out enum drops for SQLite compatibility, as they might cause errors if dialect doesn't support or if enums are not separate types.
    # payment_method_enum.drop(op.get_bind(), checkfirst=False)
    # payment_status_enum.drop(op.get_bind(), checkfirst=False)
    # gateway_transaction_status_enum.drop(op.get_bind(), checkfirst=False)
    # gateway_type_enum.drop(op.get_bind(), checkfirst=False)
    # ### end Alembic commands ###
